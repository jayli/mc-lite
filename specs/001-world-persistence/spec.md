# Feature Specification: 地图持久化与动态增量存储 (World Persistence)

**Feature Branch**: `001-world-persistence`
**Created**: 2026-01-24
**Status**: Draft
**Input**: User description: "这个游戏目前的地图的生成虽然是随机的，而且会有动态销毁的机制，但是我希望只要生成之后的地图，玩家在地图上搞的破坏以及创建的新物品，都要保留下来。内存可以回收掉，但数据需要保留，如果玩家离开这个地图，地图离开视野后被销毁，再次返回这个坐标，再次生成的地图数据应当跟离开时一致，请问这个能力如何保持高效的实现。"

## Clarifications

### Session 2026-01-24
- Q: 持久化存储的具体技术选择与生命周期要求？ → A: 优先使用 IndexedDB (LocalStorage 作为备选)；仅需在浏览器未刷新的情况下保持持久化，不要求关闭浏览器后保留。

## User Scenarios & Testing *(mandatory)*

### User Story 1 - 基础方块修改持久化 (Priority: P1)

作为一名玩家，我希望在世界中挖掘方块或放置方块后，即使我离开该区域并导致区块被卸载，当我再次回来时，我之前所做的修改依然存在。

**Why this priority**: 这是持久化功能的核心价值，确保玩家对世界的改变是永久的。

**Independent Test**: 在一个坐标点（例如 0,0）挖掉一个方块并在旁边放置一个方块。走远直到该区块在内存中被卸载（根据渲染距离），然后再走回来。验证该处的方块状态与离开前一致。

**Acceptance Scenarios**:

1. **Given** 玩家在一个新生成的区块中，**When** 玩家挖掘一个天然生成的方块，**Then** 该方块消失。
2. **Given** 玩家离开该区域导致区块卸载，**When** 玩家重新回到该区域，**Then** 被挖掘的方块位置依然是空的，而不是重新生成。
3. **Given** 玩家放置一个新方块，**When** 区块经历卸载并重新加载，**Then** 玩家放置的方块依然在原位。

---

### User Story 2 - 高效的数据加载与回收 (Priority: P2)

作为系统，我需要能够高效地存储和读取玩家的修改数据，只在必要时才加载特定区域的修改，以保持游戏运行流畅。

**Why this priority**: 纯前端项目资源有限，必须确保持久化不会导致显著的卡顿或内存溢出。

**Independent Test**: 在多个不同区块进行大量修改，通过开发者工具监控存储占用和加载时的帧率波动。

**Acceptance Scenarios**:

1. **Given** 大量已修改的区块数据存储在本地，**When** 玩家进入新区域时，**Then** 系统只加载当前视野内区块相关的修改数据，不影响游戏帧率。
2. **Given** 玩家离开某个区域，**When** 该区域的区块从内存销毁时，**Then** 与之相关的内存数据应被及时清理，仅保留持久化存储中的数据。

---

### User Story 3 - 会话内的持久化恢复 (Priority: P3)

作为一名玩家，我希望在单次浏览器会话中（未刷新页面），无论我走多远，我之前对世界的所有修改都能在我返回时完整恢复。

**Why this priority**: 提供了在单次游戏过程中的地理持久性。

**Independent Test**: 进行一系列修改，在不刷新页面的情况下长距离移动后再返回，验证修改是否依然存在。

**Acceptance Scenarios**:

1. **Given** 玩家进行了若干修改，**When** 玩家在未刷新页面的情况下重新回到修改过的区块，**Then** 所有修改都能正确恢复。

---

### Edge Cases

- **存储容量限制**：如果本地存储（IndexedDB/LocalStorage）达到上限，系统应如何处理？**已澄清：** 优先尝试 IndexedDB 以获取更大容量。
- **坐标冲突**：如果地形生成算法发生微调，导致原始生成的方块与持久化的修改数据发生冲突，如何解决？（通常以持久化数据为准）。
- **极高速移动**：玩家极快地穿过多个区块，导致频繁的 IO 操作，是否会造成掉帧？

## Requirements *(mandatory)*

### Functional Requirements

- **FR-001**: 系统必须能够记录玩家对区块进行的增量修改（挖掘、放置），而不是存储整个区块的所有数据。
- **FR-002**: 系统必须支持根据区块坐标（Chunk Coordinates）检索对应的修改记录。
- **FR-003**: 在区块生成过程中，系统必须在应用随机地形生成逻辑之后，立即叠加（Apply）该区块的持久化修改数据。
- **FR-004**: 系统必须优先利用浏览器的 IndexedDB 实现数据的持久化存储，若不可用则降级至 LocalStorage。
- **FR-005**: 持久化数据的生命周期仅限于当前浏览器会话（刷新即重置），但在会话内必须能够跨区块卸载周期。
- **FR-006**: 当区块被从内存中卸载（Dispose）时，系统必须确保所有未保存的修改已同步到持久化存储中。
- **FR-007**: 系统必须能够识别“新创建的物品”（如放置的实体或特殊方块）并将其位置和类型持久化。

### Key Entities *(include if feature involves data)*

- **WorldDelta**: 代表对原始地形的增量修改。包含区块坐标。
- **BlockChange**: 代表单个位置的变化。包含相对区块的坐标、操作类型（添加/删除）以及方块类型。

## Success Criteria *(mandatory)*

### Measurable Outcomes

- **SC-001**: 重新加载已修改区块的时间增加不应超过原生成时间的 20%。
- **SC-002**: 在主流现代浏览器（Chrome/Edge/Firefox）中，支持至少 10,000 个方块修改的流畅存取。
- **SC-003**: 玩家在移动过程中，因加载持久化数据导致的瞬间掉帧（Stutter）次数应为 0。
- **SC-004**: 数据压缩率：存储的增量数据体积应远小于完整区块数据的体积（目标：< 5%）。
